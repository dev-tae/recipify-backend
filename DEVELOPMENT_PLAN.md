# Recipify - Development Journey & Plan

## 1. Project Overview & Goals

*   **Core Concept:** AI-powered culinary assistant designed to help users generate creative and tailored recipes. Users select ingredients, specify cuisine preferences, target audience (including baby-safe options), and desired servings.
*   **MVP Goals (Family Testing):**
    *   Secure User Authentication (individual accounts).
    *   Persistent Data Storage (recipe history, saved recipes, My Kitchen).
    *   Secure Gemini API Access & Basic Generation Limits.
*   **Long-Term Vision (Conceptual):** Comprehensive meal management, meal planning calendar, community engagement, achievements, and premium tiers.
*   **Tech Stack:**
    *   **Frontend:** React with TypeScript (Originally generated by Gemini Build)
    *   **Backend:** Python (FastAPI)
    *   **Database:** PostgreSQL (via Supabase)
    *   **Authentication:** Supabase Auth (OAuth with Google, Email/Password)
    *   **Deployment:** Vercel (Frontend + Backend Serverless Functions)
    *   **AI:** Gemini API

## 2. Development Phases & Milestones

### Phase 1: Backend Foundation & Core MVP Features (Current Focus)

*   **Milestone 1.1: Basic Backend Setup (DONE)**
    *   [x] Initialize FastAPI project.
    *   [x] Configure CORS.
    *   [x] Basic health check endpoint (`/`).
    *   [x] Environment variable setup (`.env` with `python-dotenv`).
    *   [x] PyCharm environment and indexing issues resolved.
*   **Milestone 1.2: User Authentication with Supabase**
    *   [x] Set up Supabase project (DB, Auth).
    *   [x] Configure Supabase Auth providers (Email/Password, Google OAuth enabled).
    *   [x] Create `public.users` table in Supabase DB.
    *   [x] Implement `handle_new_user` trigger in Supabase to populate `public.users` on new auth sign-up.
    *   [x] Frontend: Integrate Supabase JS client (`@supabase/supabase-js`) for Sign Up, Sign In, Sign Out, and managing auth state (`onAuthStateChange`).
    *   [x] Backend: Implement FastAPI dependency (`get_current_user_from_supabase_token`) to validate Supabase JWTs received in `Authorization: Bearer` header.
    *   [x] Backend: Create `/api/users/me` endpoint (protected) to return authenticated user details from `public.users` table.
*   **Milestone 1.3: Secure Recipe Generation**
    *   [ ] Backend: Define Pydantic models for recipe generation request (`RecipeGenerationRequest`) and response (`RecipeResponse` / `RecipeErrorResponse`).
    *   [ ] Backend: Create `/api/recipes/generate` endpoint (protected by Supabase JWT auth).
        *   Accepts: ingredients, cuisine, audience, servings, `avoid_titles` (from `RecipeGenerationRequest`).
        *   Logic:
            *   Check user's generation limits (from `public.users` table).
            *   Construct Gemini prompt (Python port of `PROMPT_TEMPLATE` from frontend's `geminiService.ts`).
            *   Call Gemini API securely (using `GEMINI_API_KEY` from backend `.env`).
            *   Parse & validate Gemini JSON response (Python port of JSON repair logic from `geminiService.ts`).
            *   Return `RecipeResponse` JSON or `RecipeErrorResponse` JSON.
    *   [ ] Frontend: Refactor recipe generator UI to call this backend endpoint instead of direct Gemini calls.
*   **Milestone 1.4: Database Schema & Recipe Persistence**
    *   [ ] Backend: Define `Recipes` table schema in Supabase (e.g., using SQL in Supabase dashboard or migrations).
    *   [ ] Backend: Define `UserRecipes` table schema (linking users to recipes for history, saved status).
    *   [ ] Backend: Update `/api/recipes/generate` to:
        *   Save newly generated unique recipes to `Recipes` table (check for duplicates using a content hash or title+key ingredients).
        *   Add entry to `UserRecipes` with `status='history'` (or `is_in_history=true`) for the generating user.
        *   Implement basic history limit (e.g., if history count for user > N, remove oldest).
*   **Milestone 1.5: Recipe History API**
    *   [ ] Backend: Create `GET /api/recipes/history` endpoint (protected, paginated) to fetch user's recipe history.
    *   [ ] Backend: Create `DELETE /api/recipes/history/{recipe_id}` endpoint (protected) to remove a recipe from user's history.
    *   [ ] Frontend: Refactor "History" tab to fetch data from these APIs instead of `localStorage`.
*   **Milestone 1.6: Saved Recipes API**
    *   [ ] Backend: Create `GET /api/recipes/saved` endpoint (protected, paginated) to fetch user's saved recipes.
    *   [ ] Backend: Create `POST /api/recipes/{recipe_id}/save` endpoint (protected) to mark a recipe as saved for the user.
    *   [ ] Backend: Create `DELETE /api/recipes/{recipe_id}/unsave` endpoint (protected) to remove a recipe from saved list.
    *   [ ] Frontend: Refactor "Saved Recipes" tab and save/unsave functionality to use these APIs.
*   **Milestone 1.7: "My Kitchen" API**
    *   [ ] Backend: Define `UserKitchenIngredients` table schema in Supabase.
    *   [ ] Backend: Create `GET /api/kitchen/ingredients` endpoint (protected).
    *   [ ] Backend: Create `POST /api/kitchen/ingredients` endpoint (protected) to add ingredient(s).
    *   [ ] Backend: Create `DELETE /api/kitchen/ingredients/{ingredient_name}` endpoint (protected).
    *   [ ] Frontend: Refactor "My Kitchen" tab and "Add all from My Kitchen" functionality to use these APIs.
*   **Milestone 1.8: "Exclude from Suggestions" API**
    *   [ ] Backend: Add `excluded_recipe_titles` (e.g., `JSONB` array) column to `public.users` table.
    *   [ ] Backend: Create `POST /api/users/me/excluded-recipes` endpoint (protected) to add a recipe title to exclusion list.
    *   [ ] Backend: Create `DELETE /api/users/me/excluded-recipes/{recipe_title}` endpoint (protected) to remove.
    *   [ ] Backend: Modify recipe generation prompt logic to include these excluded titles for the current user.
    *   [ ] Frontend: Implement UI for excluding/un-excluding recipes and sync with backend.
*   **Milestone 1.9: Basic Tier Logic & Generation Limits**
    *   [ ] Backend: Ensure `daily_generation_count`, `last_generation_reset_date`, `is_paid_status` fields exist and are used in `public.users`.
    *   [ ] Backend: Implement logic in `/api/recipes/generate` to check and decrement `daily_generation_count`.
    *   [ ] Backend: (Conceptual - can be manual DB update for MVP) Daily job/check to reset `daily_generation_count`. Supabase scheduled functions could do this.
    *   [ ] Frontend: Implement (simulated) "Upgrade to Pro" toggle. This will call a new backend endpoint (e.g., `PUT /api/users/me/status { is_paid: true/false }`) to update the user's status in the DB.

### Phase 2: MVP Deployment & Family Testing

*   [ ] Deploy Backend API (FastAPI Python functions) to Vercel.
*   [ ] Deploy Frontend React App to Vercel.
*   [ ] Configure all necessary environment variables on Vercel for both frontend (e.g., `VITE_SUPABASE_URL`, `VITE_SUPABASE_ANON_KEY`) and backend (`SUPABASE_URL`, `SUPABASE_SERVICE_KEY`, `GEMINI_API_KEY`, `DATABASE_URL` from Supabase).
*   [ ] Thorough end-to-end testing of all MVP features by the development team.
*   [ ] Create accounts for family members and guide them on using the app.
*   [ ] Collect feedback systematically (e.g., shared doc, simple form).

### Phase 3: Post-MVP Enhancements (Based on Feedback & Priorities)

*   **Feature: Meal Calendar**
    *   API design: Endpoints for adding, viewing (by month/day), editing, deleting calendar entries.
    *   Database schema for calendar entries, linking to users and recipes.
*   **Feature: Achievements & Streaks**
    *   API design: Endpoints for tracking user progress (cooked counts, etc.), fetching available/unlocked achievements.
    *   Database schema for user progress metrics and achievements.
*   **Feature: "Mark as Cooked"**
    *   API design: Endpoint to mark a recipe as cooked, potentially with a date.
    *   Update `UserRecipes` or a separate `CookedHistory` table.
*   **Enhanced Error Handling & Logging (Backend)**: Implement more structured logging (e.g., using Python's `logging` module, potentially sending logs to a service).
*   **Refinements to UI/UX based on family feedback.**
*   **Admin/Moderation tools (if community features are pursued later).**

### Phase 4: Conceptual/Future Features

*   Community Feed (Real-time, User Posts, Likes, Comments)
*   Payment Gateway Integration (e.g., Stripe, for actual "Recipify Pro" subscriptions)
*   Advanced Search & Filtering (e.g., by nutrition, prep time ranges)
*   Offline Capabilities (Progressive Web App features)

## 3. API Endpoint Design (High-Level)

*(This section will be populated with more detail as we implement each endpoint)*

*   **Auth (Interacts with Supabase Auth; backend validates tokens & manages user profiles):**
    *   `GET /api/users/me`
    *   `PUT /api/users/me/status` (for simulated premium toggle)
*   **Recipe Generation:**
    *   `POST /api/recipes/generate`
*   **Recipe Management:**
    *   `GET /api/recipes/history`
    *   `DELETE /api/recipes/history/{recipe_id}`
    *   `GET /api/recipes/saved`
    *   `POST /api/recipes/{recipe_id}/save`
    *   `DELETE /api/recipes/{recipe_id}/unsave`
*   **My Kitchen:**
    *   `GET /api/kitchen/ingredients`
    *   `POST /api/kitchen/ingredients`
    *   `DELETE /api/kitchen/ingredients/{ingredient_name}`
*   **User Preferences/Settings:**
    *   `POST /api/users/me/excluded-recipes`
    *   `DELETE /api/users/me/excluded-recipes/{recipe_title}`

## 4. Database Schema (High-Level - via Supabase)

*   **`auth.users` (Managed by Supabase)**
    *   `id` (uuid, pk)
    *   `email` (text)
    *   ... (other Supabase auth fields like `encrypted_password`, `created_at`, `updated_at`, etc.)
*   **`public.users`** (Mirrors/extends `auth.users` for app-specific data)
    *   `id` (uuid, primary key, foreign key references `auth.users.id` ON DELETE CASCADE)
    *   `email` (text, unique, not null)
    *   `name` (text, nullable)
    *   `is_paid_status` (boolean, default `false`, not null)
    *   `daily_generation_count` (integer, default `0`, not null)
    *   `last_generation_reset_date` (date)
    *   `excluded_recipe_titles` (jsonb, nullable)
    *   `created_at` (timestamp with time zone, default `now()`, not null)
    *   `updated_at` (timestamp with time zone, default `now()`, not null)
*   **`public.recipes`** (Stores unique recipe definitions)
    *   `id` (uuid, primary key, default `gen_random_uuid()`)
    *   `title` (text, not null)
    *   `description` (text)
    *   `prep_time` (text)
    *   `cook_time` (text)
    *   `servings_description` (text)
    *   `ingredients_json` (jsonb, not null)
    *   `instructions_json` (jsonb, not null)
    *   `notes_json` (jsonb, nullable)
    *   `cuisine` (text)
    *   `audience` (text)
    *   `generated_by_user_id` (uuid, nullable, foreign key references `public.users.id` ON DELETE SET NULL)
    *   `created_at` (timestamp with time zone, default `now()`, not null)
    *   `content_hash` (text, unique, nullable) -- MD5 or SHA256 hash of key recipe content fields to detect exact duplicates.
*   **`public.user_recipes`** (Associates users with recipes for history, saved, cooked status)
    *   `user_id` (uuid, foreign key references `public.users.id` ON DELETE CASCADE, not null)
    *   `recipe_id` (uuid, foreign key references `public.recipes.id` ON DELETE CASCADE, not null)
    *   `is_in_history` (boolean, default `false`, not null)
    *   `history_added_at` (timestamp with time zone, nullable)
    *   `is_saved` (boolean, default `false`, not null)
    *   `saved_at` (timestamp with time zone, nullable)
    *   `is_cooked` (boolean, default `false`, not null)
    *   `last_cooked_at` (timestamp with time zone, nullable)
    *   `cooked_count` (integer, default `0`, not null)
    *   PRIMARY KEY (`user_id`, `recipe_id`)
*   **`public.user_kitchen_ingredients`**
    *   `user_id` (uuid, foreign key references `public.users.id` ON DELETE CASCADE, not null)
    *   `ingredient_name` (text, not null)
    *   `added_at` (timestamp with time zone, default `now()`, not null)
    *   PRIMARY KEY (`user_id`, `ingredient_name`)

## 5. Key Decisions & Notes

*   **2025-05-22:** Chose Supabase for Authentication & PostgreSQL Database to accelerate MVP development and leverage its robust auth features.
*   **2025-05-22:** Confirmed Python/FastAPI for backend development due to familiarity and robust ecosystem.
*   **Note:** The frontend `geminiService.ts` logic for prompt engineering and JSON repair needs to be carefully ported to Python for the backend recipe generation endpoint.
*   **Note:** All list endpoints (`/history`, `/saved`) must implement pagination to handle potentially large datasets.
*   **Note:** Ensure all sensitive keys (`GEMINI_API_KEY`, `SUPABASE_SERVICE_KEY`, `DATABASE_URL`) are stored in `.env` and `.env` is in `.gitignore`. (DONE for backend `.env`)
*   **Note:** Backend JWT validation will initially use Supabase's `/auth/v1/user` endpoint for simplicity, can explore local JWT validation with JWKS later for optimization.
*   **Note:** Consider using Alembic or Supabase's built-in migration tools for managing database schema changes once the initial schema is defined.